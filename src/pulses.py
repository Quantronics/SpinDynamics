"""Pulses functions for different sequences."""
import numpy as np
from qutip import *
from src.utility import *


def projection_pulse(t, args):
    """Programs the pi/2-pulses applied at the beginning and the end of a CPMG or XY sequence.

    Parameters
    ----------
    t: float
        Time variable

    args: dictionary of parameters used by the solver.
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
        - N_pulses: Total number of pi pulses
    """
    tau = args['tau']
    pulse_duration = args['pi_pulse_duration'] / 2  # pi/2 pulse
    rabi_freq = args['rabi_freq']
    kappa_c = args['kappa_c']
    kappa = args['kappa']
    N_pulses = args['N_pulses']

    end_of_sequence = N_pulses * 2 * tau # End of the pi-pulse sequence
    t_ending = t - end_of_sequence

    # Apply a pi/2 pulse before the pi-pulses sequence
    if t < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t / 2))
    elif t >= pulse_duration and t_ending < 0:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t - pulse_duration) / 2)

    # Apply a pi/2 pulse after the pi-pulses sequence
    elif t_ending > 0 and t_ending < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t_ending / 2))
    elif t_ending >= pulse_duration:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t_ending - pulse_duration) / 2)

    else:
        return 0


"""CPMG Sequence."""
def input_CPMG_pulse(t,tau,pulse_duration):
    """Pulse function of a CPMG sequence generated by the MW sources and 
    sent to the cavity.
    
    Parameters
    ----------
    t: float
        Time variable.
        
    tau: float
        Free evolution time of the sequence (the interpulse is 2*tau).
        
    pulse_duration: float
        Duration of the generated pulse.
    """
    rabi_freq = 2*np.pi / pulse_duration
    t_module =  t%(2*tau) - tau
    if t_module > 0 and t_module < pulse_duration:
        return rabi_freq / 2
    else:
        return 0


def calculate_CPMG_pulse(t, args):
    """Pulse function of a CPMG sequence actually seen by the electronic spin.
    Computes the real shape based on the signal generated by the MW sources.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of parameters used by the solver.
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
        - N_pulses: Total number of pi pulses
    """
    tau = args['tau']
    pulse_duration = args['pi_pulse_duration']
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    N_pulses = args['N_pulses']

    # Do not apply pi-pulses when we mean to apply pi/2-pulses
    end_of_sequence = N_pulses * 2 * tau
    if t > end_of_sequence:
        return 0

    t_module = t % (2 * tau) - tau

    if t_module > 0 and t_module < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t_module / 2))
    elif t_module > 0 and t_module >= pulse_duration:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t_module - pulse_duration) / 2)
    else:
        return 0


def input_imbalanced_CPMG_pulse(t, tau, delta_tau, pulse_duration):
    rabi_freq = 2*np.pi / pulse_duration
    tau1 = tau-delta_tau
    tau2 = tau+delta_tau
    t_module =  t%(2*(tau1+tau2)) - tau1
    if t_module > 0 and t_module < pulse_duration:
        return rabi_freq / 4
    elif  t_module > 2*tau2 and t_module < 2*tau2+pulse_duration:
        return rabi_freq / 4
    else:
        return 0


def calculate_imbalanced_CPMG_pulse(t, args):
    tau = args['tau']
    delta_tau = args['delta_tau']
    pulse_duration = args['pi_pulse_duration']
    pulse_duration = args['pi_pulse_duration']
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    N_pulses = args['N_pulses']

    # Do not apply pi-pulses when we mean to apply pi/2-pulses
    end_of_sequence = N_pulses * 2 * tau
    if t > end_of_sequence:
        return 0
    return input_imbalanced_CPMG_pulse(t, tau, delta_tau, pulse_duration) 


"""XY Sequence."""
def calculate_pi_x_pulse(t, args):
    """X-Pulse function of a XY sequence actually seen by the electronic spin.
    Computes the real shape based on the signal generated by the MW sources.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of parameters used by the solver.
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
        - N_pulses: Total number of pi pulses
    """
    tau = args['tau']
    pulse_duration = args['pi_pulse_duration']
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    N_pulses = args['N_pulses']
    
    # Safeguard for added time instants to apply the last pi/2 pulse
    end_of_sequence = N_pulses*2*tau
    if t > end_of_sequence:
        return 0
    
    t_module =  t%(4*tau) - tau
    
    if t_module > 0 and t_module < pulse_duration:
        return np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*t_module/2))
    elif t_module > 0 and t_module >= pulse_duration:
        C = np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*pulse_duration/2))
        return C*np.exp(-kappa*(t_module-pulse_duration)/2)
    else:
        return 0
    
def calculate_pi_y_pulse(t, args):
    """Y-Pulse function of a XY sequence actually seen by the electronic spin.
    Computes the real shape based on the signal generated by the MW sources.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of parameters used by the solver.
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
        - N_pulses: Total number of pi pulses
    """
    tau = args['tau']
    pulse_duration = args['pi_pulse_duration']
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    N_pulses = args['N_pulses']
    
    # Safeguard for added time instants to apply the last pi/2 pulse
    end_of_sequence = N_pulses*2*tau
    if t > end_of_sequence:
        return 0
    
    t_module =  t%(4*tau) - 3*tau
    
    if t_module > 0 and t_module < pulse_duration:
        return np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*t_module/2))
    elif t_module > 0 and t_module >= pulse_duration:
        C = np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*pulse_duration/2))
        return C*np.exp(-kappa*(t_module-pulse_duration)/2)
    else:
        return 0


"""HHDR Sequence."""
def HHDR_pulse(t,args):
    """Pulse function of a Hartmann-Hahn Double Resonance (HHDR) sequence 
    actually seen by the electronic spin.
    Computes the real shape based on the signal generated by the MW sources.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of parameters used by the solver.
        - HHDR_pulse_duration: Duration of the pulse generated by the MW sources.
        - HHDR_amplitude: Maximum amplitude of the pulse.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    HHDR_duration = args['HHDR_pulse_duration']
    amp = args['HHDR_amplitude']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    
    start_of_HHDR = 4 # start HHDR after 4 us
    
    if t > start_of_HHDR and t < start_of_HHDR + HHDR_duration:
        return amp*(1-np.exp(-kappa*(t-start_of_HHDR)/2))
    elif t > start_of_HHDR and t >= start_of_HHDR + HHDR_duration:
        C = amp*(1-np.exp(-kappa*(HHDR_duration)/2))
        return C*np.exp(-kappa*(t-start_of_HHDR - HHDR_duration)/2)
    else:
        return 0

def projection_HHDR_pulse(t,args):
    """Programs the pi/2-pulses applied at the beginning and the end of a HHDR sequence.

    Parameters
    ----------
    t: float
        Time variable

    args: dictionary of parameters used by the solver.
        - HHDR_pulse_duration: Duration of the HHDR pulse generated by the MW sources.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    HHDR_duration = args['HHDR_pulse_duration']
    pulse_duration = args['pi_pulse_duration'] / 2 # pi/2 pulse
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    
    end_of_HHDR = HHDR_duration + 10 # wait 10 us after end of HHDR pulse 
    t_ending = t-end_of_HHDR
    
    if t < pulse_duration:
        return np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*t/2))
    elif t > pulse_duration and t_ending < 0:
        C = np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*pulse_duration/2))
        return C*np.exp(-kappa*(t-pulse_duration)/2)
    
    elif t_ending > 0 and t_ending < pulse_duration:
        return -np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*t_ending/2))
    elif t_ending > pulse_duration:
        C = np.sqrt(kappa_c)*rabi_freq/kappa*(1-np.exp(-kappa*pulse_duration/2))
        return -C*np.exp(-kappa*(t_ending-pulse_duration)/2)
    
    else:
        return 0


def applied_CPMG_pulse(t, args):
    return calculate_CPMG_pulse(t, args) + projection_pulse(t, args)


def applied_XY_pulse(t,args):
    return calculate_pi_x_pulse(t,args)+calculate_pi_y_pulse(t,args)+projection_pulse(t,args)


def parallelize_CPMG(H, ket0, sim_args, nS, *args):
    """Plots the expect values of electron spin operator along x,y,z.
    
    Parameters
    ----------
    H: Qobj
        Total Hamiltonian of the system
        
    ket0: Qobj
        Initial state of the system (usually an eigenstate of H0)
        
    sim_args: dictionary of float values
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
        
    nS: int
        Dimension of the electron spin subspace
        
    *args: arbitrarily-long list of nuclear spin operators dimensions
    Note: it correspond to the dimensions of all the nuclear spin
    subspaces.
    (e.g. [nI_1, nI_2, nI_3] if there are 3 nuclear spins in the system)
    """
    
    tau = sim_args['tau']
    pulse_duration = sim_args['pi_pulse_duration']
    kappa = sim_args['kappa']
    N_pulses = sim_args['N_pulses']
    
    t = initialize_time_list(N_pulses, tau, pulse_duration, kappa)
    
    result = mesolve(H, ket0, t, [], [], sim_args)

    e_spin_down = basis(nS,1)
    
    ops = (e_spin_down * e_spin_down.dag(),) + generate_identity_ops(*args)
    return expect(tensor(*ops), result.states)[-1]