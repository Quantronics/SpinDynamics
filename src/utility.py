"""Various scripts that we want to encapsulate away from the notebook"""
import numpy as np
from qutip import *
from scipy.sparse import dia_matrix
import matplotlib.pyplot as plt


def generate_S(S: float) -> (Qobj, Qobj, Qobj):
    mS = np.arange(S, -S-1, -1)
    nS = len(mS)
    S_plus = Qobj(dia_matrix((np.sqrt(S*(S+1)-mS*(mS+1)),1), shape = (nS, nS)).A)
    S_minus = Qobj(np.transpose(S_plus))
    Sx = Qobj(0.5*(S_plus+S_minus))
    Sy = Qobj(-0.5*1j*(S_plus-S_minus))
    Sz = Qobj(dia_matrix((mS,0), shape = (nS, nS)).A)

    return (Sx,Sy,Sz)


def generate_I(I: float) -> (Qobj, Qobj, Qobj):
    mI = np.arange(I, -I-1, -1)
    nI = len(mI)
    I_plus = Qobj(dia_matrix((np.sqrt(I*(I+1)-mI*(mI+1)),1), shape = (nI, nI)).A)
    I_minus = Qobj(np.transpose(I_plus))
    Ix = 0.5*(I_plus+I_minus)
    Iy = -0.5*1j*(I_plus-I_minus)
    Iz = Qobj(dia_matrix((mI,0), shape = (nI, nI)).A)

    return (Ix,Iy,Iz)


def initialize_time_list(N_pulses, tau, pulse_duration, kappa):
    """Initialize a time list with increased resolution when pulses are applied.
    Note: If there are duplicate time instants, the solver will not run the simulation.

    Parameters
    ----------
    N_pulses: int
        Number of pulses to apply to the e- spin (N_pulses//2 unit
        control sequences in total).

    tau: float
        Free evolution time of the sequence (the interpulse is 2*tau).

    pulse_duration: float
        Duration of a single pulse.

    Returns
    -------
    t: np.ndarray
        Time list to be used by the solver.
    """
    t = []
    t1 = tau - 0.1 * pulse_duration
    t2 = tau + pulse_duration + 4 / kappa

    # Setting up a good resolution for the first pi/2 pulse
    t = np.linspace(0, pulse_duration + 4 / kappa, 200).tolist()
    t += np.linspace(pulse_duration + 4 / kappa + 1e-3, t1 - 1e-3, 50).tolist()
    t += np.linspace(t1, t2, 100).tolist()
    t += np.linspace(t2 + 1e-3, 2 * tau - 1e-3, 50).tolist()

    for k in range(1, N_pulses):
        step = k * 2 * tau
        t_before_pulse = np.linspace(0 + step, t1 - 1e-3 + step, 50).tolist()
        t_during_pulse = np.linspace(t1 + step, t2 + step, 100).tolist()
        t_after_pulse = np.linspace(t2 + 1e-3 + step, 2 * tau - 1e-3 + step, 50).tolist()
        t += (t_before_pulse + t_during_pulse + t_after_pulse)

    # Adding time instants for final pi/2 pulse
    t += np.linspace(N_pulses * 2 * tau, N_pulses * 2 * tau + t2, 200).tolist()

    return np.array(t)


def projection_CPMG_pulse(t, args):
    """Programs the pi/2-pulses applied at the beginning and the end of a CPMG sequence.

    Parameters
    ----------
    t: float
        Time variable

    args: dictionary of float values
        - tau: Free evolution time.
        - pulse_duration: Duration of the pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.

    Returns
    -------
    t: np.ndarray
        Time list to be used by the solver.
    """
    tau = args['tau']
    pulse_duration = args['pulse_duration'] / 2  # pi/2 pulse
    rabi_freq = args['rabi_freq']
    kappa_c = args['kappa_c']
    kappa = args['kappa']
    N_pulses = args['N_pulses']

    end_of_sequence = N_pulses * 2 * tau # End of the pi-pulse sequence
    t_ending = t - end_of_sequence

    # Apply a pi/2 pulse before the pi-pulses sequence
    if t < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t / 2))
    elif t >= pulse_duration and t_ending < 0:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t - pulse_duration) / 2)

    # Apply a pi/2 pulse after the pi-pulses sequence
    elif t_ending > 0 and t_ending < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t_ending / 2))
    elif t_ending >= pulse_duration:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t_ending - pulse_duration) / 2)

    else:
        return 0


def input_CPMG_pulse(t,tau,pulse_duration):
    """Pulse function of a CPMG sequence generated by the MW sources and 
    sent to the cavity.
    
    Parameters
    ----------
    t: float
        Time variable.
        
    tau: float
        Free evolution time of the sequence (the interpulse is 2*tau).
        
    pulse_duration: float
        Duration of the generated pulse.
    """
    rabi_freq = 2*np.pi*5
    pulse_duration = 2*np.pi / rabi_freq / 2
    t_module =  t%(2*tau) - tau
    if t_module > 0 and t_module < pulse_duration:
        return rabi_freq / 2
    else:
        return 0


def calculate_CPMG_pulse(t, args):
    """Pulse function of a CPMG sequence actually seen by the electronic spin.
    Computes the real shape based on the signal generated by the MW sources.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of float values
        - tau: Free evolution time.
        - pulse_duration: Duration of the pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    
    tau = args['tau']
    pulse_duration = args['pulse_duration']
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    N_pulses = args['N_pulses']

    # Do not apply pi-pulses when we mean to apply pi/2-pulses
    end_of_sequence = N_pulses * 2 * tau
    if t > end_of_sequence:
        return 0

    t_module = t % (2 * tau) - tau

    if t_module > 0 and t_module < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t_module / 2))
    elif t_module > 0 and t_module >= pulse_duration:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t_module - pulse_duration) / 2)
    else:
        return 0


def generate_identity_ops(*args):
    """Generates a tuple of an arbitrary number of qeye operators with
    the dimensions provided by the user.
    The resulting tuple can then be passed to any QuTip function,
    especially expect().
    
    Parameters
    ----------
    *args: arbitrarily-long list of operators dimensions
    
    Returns
    -------
    ops: tuple of qeye operators with dimensions given in *args.
    """
    ops = ()
    n_spins = len(args)
    for i in range(n_spins):
        ops += (qeye(args[i]),)
        
    return ops
    

"""Plotting functions."""

def applied_CPMG_pulse(t, args):
    return calculate_CPMG_pulse(t, args) + projection_CPMG_pulse(t, args)

def plot_CPMG_pulses(t, args):
    tau = args['tau']
    pulse_duration = args['pulse_duration']
    
    a_in_list = [input_CPMG_pulse(time,tau,pulse_duration) for time in t]
    a_list = [applied_CPMG_pulse(time,args) for time in t]

    fig, axes = plt.subplots(2, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.supylabel("Rabi frequency (MHz)")

    axes[0].plot(t,a_in_list,'o-')
    axes[0].set_title("MW pulses sent to the cavity")
    axes[1].plot(t,a_list,'o-')
    axes[1].set_title("MW pulses inside the cavity")
    
    return axes


def inspect_electron_spin(t, result, S, *args):
    """Plots the expect values of the electron spin operator along x,y,z.
    
    Parameters
    ----------
    t: np.ndarray of floats
        Time list
        
    result: np.ndarray of Qobj
        List of statevectors obtained by the simulation
        
    S: int
        Electron spin quantum number
        
    *args: arbitrarily-long list of nuclear spin operators dimensions
    Note: it correspond to the dimensions of all the nuclear spin
    subspaces.
    (e.g. [nI_1, nI_2, nI_3] if there are 3 nuclear spins in the system)
    """
    (Sx,Sy,Sz) = generate_S(S)
    
    ops = generate_identity_ops(*args)
        
    e_spin_x = expect(tensor(*((Sx,) + ops)), result.states)
    e_spin_y = expect(tensor(*((Sy,) + ops)), result.states)
    e_spin_z = expect(tensor(*((Sz,) + ops)), result.states)

    fig, axes = plt.subplots(3, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.suptitle(r"Average of the spin operator of the electron $< \vec{S} >$")

    axes[0].set_ylabel(r"$<S_x>$")
    axes[0].plot(t, e_spin_x)

    axes[1].set_ylabel(r"$<S_y>$")
    axes[1].plot(t, e_spin_y)

    axes[2].set_ylabel(r"$<S_z>$")
    axes[2].plot(t, e_spin_z)
    
    return axes


def inspect_nuclear_spin(spin_number, t, result, I, *args):
    """Plots the expect values of the nuclear spin operator along x,y,z
    for the chosen nuclear spin.
    
    Parameters
    ----------
    spin_number: int
        Number of the nuclear spin to inspect (1 if there is only one
    nuclear spin in the system).
    
    t: np.ndarray of floats
        Time list
        
    result: np.ndarray of Qobj
        List of statevectors obtained by the simulation
        
    I: int
        Nuclear spin quantum number
        
    *args: arbitrarily-long list of electron and nuclear spin operators 
    dimensions. 
    Note: it correspond to the dimensions of all the spin
    subspaces that do not correspond to the one inspected.
    (e.g. [nS, nI_1, nI_3] if there are 3 nuclear spins and the spin #2
    is the one of interest)
    """
    (Ix,Iy,Iz) = generate_I(I)
    
    n_spins = len(args)
    if n_spins == 1:
        n_spin_x = expect(tensor(qeye(args[0]), Ix), result.states)
        n_spin_y = expect(tensor(qeye(args[0]), Iy), result.states)
        n_spin_z = expect(tensor(qeye(args[0]), Iz), result.states)
    else:
        ops_1 = generate_identity_ops(*args[0:spin_number])
        ops_2 = generate_identity_ops(*args[spin_number:])
        n_spin_x = expect(tensor(*(ops_1 + (Ix,) + ops_2)), result.states)
        n_spin_y = expect(tensor(*(ops_1 + (Iy,) + ops_2)), result.states)
        n_spin_z = expect(tensor(*(ops_1 + (Iz,) + ops_2)), result.states)

    fig, axes = plt.subplots(3, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.suptitle(r"Average of the spin operator of the nucleus $< \vec{I} >$")

    axes[0].set_ylabel(r"$<I_x>$")
    axes[0].plot(t, n_spin_x)

    axes[1].set_ylabel(r"$<I_y>$")
    axes[1].plot(t, n_spin_y)

    axes[2].set_ylabel(r"$<I_z>$")
    axes[2].plot(t, n_spin_z)
    
    return axes


def parallelize_CPMG(H, ket0, sim_args, nS, *args):
        """Plots the expect values of electron spin operator along x,y,z.
    
    Parameters
    ----------
    H: Qobj
        Total Hamiltonian of the system
        
    ket0: Qobj
        Initial state of the system (usually an eigenstate of H0)
        
    sim_args: dictionary of float values
        - tau: Free evolution time.
        - pulse_duration: Duration of the pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
        
    nS: int
        Dimension of the electron spin subspace
        
    *args: arbitrarily-long list of nuclear spin operators dimensions
    Note: it correspond to the dimensions of all the nuclear spin
    subspaces.
    (e.g. [nI_1, nI_2, nI_3] if there are 3 nuclear spins in the system)
    """
    
    tau = sim_args['tau']
    pulse_duration = sim_args['pulse_duration']
    kappa = sim_args['kappa']
    N_pulses = sim_args['N_pulses']
    
    t = initialize_time_list(N_pulses, tau, pulse_duration, kappa)
    
    result = mesolve(H, ket0, t, [], [], sim_args)

    e_spin_down = basis(nS,1)
    
    ops = (e_spin_down * e_spin_down.dag(),) + generate_identity_ops(*args)
    return expect(tensor(*ops), result.states)[-1]