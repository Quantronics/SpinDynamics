"""Various scripts that we want to encapsulate away from the notebook"""
import numpy as np
from qutip import *
from scipy.sparse import dia_matrix
import matplotlib.pyplot as plt


def generate_S(S: float) -> (Qobj, Qobj, Qobj):
    mS = np.arange(S, -S-1, -1)
    nS = len(mS)
    S_plus = Qobj(dia_matrix((np.sqrt(S*(S+1)-mS*(mS+1)),1), shape = (nS, nS)).A)
    S_minus = Qobj(np.transpose(S_plus))
    Sx = Qobj(0.5*(S_plus+S_minus))
    Sy = Qobj(-0.5*1j*(S_plus-S_minus))
    Sz = Qobj(dia_matrix((mS,0), shape = (nS, nS)).A)

    return (Sx,Sy,Sz)


def generate_I(I: float) -> (Qobj, Qobj, Qobj):
    mI = np.arange(I, -I-1, -1)
    nI = len(mI)
    I_plus = Qobj(dia_matrix((np.sqrt(I*(I+1)-mI*(mI+1)),1), shape = (nI, nI)).A)
    I_minus = Qobj(np.transpose(I_plus))
    Ix = 0.5*(I_plus+I_minus)
    Iy = -0.5*1j*(I_plus-I_minus)
    Iz = Qobj(dia_matrix((mI,0), shape = (nI, nI)).A)

    return (Ix,Iy,Iz)


def initialize_time_list(N_pulses, tau, pulse_duration, kappa):
    """Initialize a time list with increased resolution when pulses are applied.
    Note: If there are duplicate time instants, the solver will not run the simulation.

    Parameters
    ----------
    N_pulses: int
        Number of pulses to apply to the e- spin (N_pulses//2 unit
        control sequences in total).

    tau: float
        Free evolution time of the sequence (the interpulse is 2*tau).

    pulse_duration: float
        Duration of a single pulse.

    Returns
    -------
    t: np.ndarray
        Time list to be used by the solver.
    """
    t = []
    t1 = tau - 0.1 * pulse_duration
    t2 = tau + pulse_duration + 4 / kappa

    # Setting up a good resolution for the first pi/2 pulse
    t = np.linspace(0, pulse_duration + 4 / kappa, 200).tolist()
    t += np.linspace(pulse_duration + 4 / kappa + 1e-3, t1 - 1e-3, 50).tolist()
    t += np.linspace(t1, t2, 100).tolist()
    t += np.linspace(t2 + 1e-3, 2 * tau - 1e-3, 50).tolist()

    for k in range(1, N_pulses):
        step = k * 2 * tau
        t_before_pulse = np.linspace(0 + step, t1 - 1e-3 + step, 50).tolist()
        t_during_pulse = np.linspace(t1 + step, t2 + step, 100).tolist()
        t_after_pulse = np.linspace(t2 + 1e-3 + step, 2 * tau - 1e-3 + step, 50).tolist()
        t += (t_before_pulse + t_during_pulse + t_after_pulse)

    # Adding time instants for final pi/2 pulse
    t += np.linspace(N_pulses * 2 * tau, N_pulses * 2 * tau + t2, 200).tolist()

    return np.array(t)


def projection_pulse(t, args):
    tau = args['tau']
    pulse_duration = args['pulse_duration'] / 2  # pi/2 pulse
    rabi_freq = args['rabi_freq']
    kappa_c = args['kappa_c']
    kappa = args['kappa']
    N_pulses = args['N_pulses']

    end_of_sequence = N_pulses * 2 * tau # End of the pi-pulse sequence
    t_ending = t - end_of_sequence

    # Apply a pi/2 pulse before the pi-pulses sequence
    if t < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t / 2))
    elif t >= pulse_duration and t_ending < 0:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t - pulse_duration) / 2)

    # Apply a pi/2 pulse after the pi-pulses sequence
    elif t_ending > 0 and t_ending < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t_ending / 2))
    elif t_ending >= pulse_duration:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t_ending - pulse_duration) / 2)

    else:
        return 0


def input_pulse(t,tau,pulse_duration):
    """Pulse function generated by the MW sources and sent to the cavity.
    
    Parameters
    ----------
    t: float
        Time variable.
        
    tau: float
        Free evolution time of the sequence (the interpulse is 2*tau).
        
    pulse_duration: float
        Duration of the generated pulse.
    """
    rabi_freq = 2*np.pi*5
    pulse_duration = 2*np.pi / rabi_freq / 2
    t_module =  t%(2*tau) - tau
    if t_module > 0 and t_module < pulse_duration:
        return rabi_freq / 2
    else:
        return 0


def calculate_pulse(t, args):
    tau = args['tau']
    pulse_duration = args['pulse_duration']
    rabi_freq = args['rabi_freq']
    kappa = args['kappa']
    kappa_c = args['kappa_c']
    N_pulses = args['N_pulses']

    # Do not apply pi-pulses when we mean to apply pi/2-pulses
    end_of_sequence = N_pulses * 2 * tau
    if t > end_of_sequence:
        return 0

    t_module = t % (2 * tau) - tau

    if t_module > 0 and t_module < pulse_duration:
        return np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * t_module / 2))
    elif t_module > 0 and t_module >= pulse_duration:
        C = np.sqrt(kappa_c) * rabi_freq / kappa * (1 - np.exp(-kappa * pulse_duration / 2))
        return C * np.exp(-kappa * (t_module - pulse_duration) / 2)
    else:
        return 0


def applied_pulse(t, args):
    return calculate_pulse(t, args) + projection_pulse(t, args)


def plot_pulses(t, args):
    tau = args['tau']
    pulse_duration = args['pulse_duration']
    
    a_in_list = [input_pulse(time,tau,pulse_duration) for time in t]
    a_list = [applied_pulse(time,args) for time in t]

    fig, axes = plt.subplots(2, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.supylabel("Rabi frequency (MHz)")

    axes[0].plot(t,a_in_list,'o-')
    axes[0].set_title("MW pulses sent to the cavity")
    axes[1].plot(t,a_list,'o-')
    axes[1].set_title("MW pulses inside the cavity")
    
    return axes


def inspect_electron_spin(t, result, S, nI):
    (Sx,Sy,Sz) = generate_S(S)
    
    e_spin_x = expect(tensor(Sx, qeye(nI)), result.states)
    e_spin_y = expect(tensor(Sy, qeye(nI)), result.states)
    e_spin_z = expect(tensor(Sz, qeye(nI)), result.states)

    fig, axes = plt.subplots(3, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.suptitle("Average of the spin operator of the electron $< \vec{S} >$")

    axes[0].set_ylabel(r"$<S_x>$")
    axes[0].plot(t, e_spin_x)

    axes[1].set_ylabel(r"$<S_y>$")
    axes[1].plot(t, e_spin_y)

    axes[2].set_ylabel(r"$<S_z>$")
    axes[2].plot(t, e_spin_z)
    
    return axes


def inspect_nuclear_spin(t, result, I, nS):
    (Ix,Iy,Iz) = generate_I(I)
    
    n_spin_x = expect(tensor(qeye(nS), Ix), result.states)
    n_spin_y = expect(tensor(qeye(nS), Iy), result.states)
    n_spin_z = expect(tensor(qeye(nS), Iz), result.states)

    fig, axes = plt.subplots(3, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.suptitle("Average of the spin operator of the nucleus $< \vec{I} >$")

    axes[0].set_ylabel(r"$<I_x>$")
    axes[0].plot(t, n_spin_x)

    axes[1].set_ylabel(r"$<I_y>$")
    axes[1].plot(t, n_spin_y)

    axes[2].set_ylabel(r"$<I_z>$")
    axes[2].plot(t, n_spin_z)
    
    return axes


def tau_parallelism(H, ket0, nS, nI, args):
    tau = args['tau']
    pulse_duration = args['pulse_duration']
    kappa = args['kappa']
    N_pulses = args['N_pulses']
    
    t = initialize_time_list(N_pulses, tau, pulse_duration, kappa)
    
    result = mesolve(H, ket0, t, [], [], args)

    e_spin_down = basis(nS,1)
    return expect(tensor(e_spin_down * e_spin_down.dag(), qeye(nI)), result.states)[-1]