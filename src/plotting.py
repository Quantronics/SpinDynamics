"""Plotting functions."""
import matplotlib.pyplot as plt
# from src.pulses import *
from src.utility import *


def plot_CPMG_pulses(t, args):
    """Functions to plot the MW pulse sent to the cavity for a CPMG sequence
    as well as the pulse inside the cavity.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of float values
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    tau = args['tau']
    pulse_duration = args['pi_pulse_duration']
    
    a_in_list = [input_CPMG_pulse(time,tau,pulse_duration) for time in t]
    a_list = [applied_CPMG_pulse(time,args) for time in t]

    fig, axes = plt.subplots(2, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.supylabel("Rabi frequency (MHz)")

    axes[0].plot(t,a_in_list,'o-')
    axes[0].set_title("MW pulses sent to the cavity")
    axes[1].plot(t,a_list,'o-')
    axes[1].set_title("MW pulses inside the cavity")
    
    return axes


def plot_imbalanced_CPMG_pulses(t, args):
    """Functions to plot the MW pulse sent to the cavity for a CPMG sequence
    as well as the pulse inside the cavity.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of float values
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    tau = args['tau']
    delta_tau = args['delta_tau']
    pulse_duration = args['pi_pulse_duration']
    
    a_in_list = [input_imbalanced_CPMG_pulse(time,tau,delta_tau,pulse_duration) for time in t]
    #a_list = [applied_CPMG_pulse(time,args) for time in t]

    fig, axes = plt.subplots(2, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.supylabel("Rabi frequency (MHz)")

    axes[0].plot(t,a_in_list,'o-')
    axes[0].set_title("MW pulses sent to the cavity")
    #axes[1].plot(t,a_list,'o-')
    axes[1].set_title("MW pulses inside the cavity")
    
    return axes


def plot_XY_pulses(t, args):
    """Functions to plot the MW pulse sent to the cavity for a XY sequence
    as well as the pulse inside the cavity.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of float values
        - tau: Free evolution time.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    tau = args['tau']
    pulse_duration = args['pi_pulse_duration']
    
    a_in_list = [input_CPMG_pulse(time,tau,pulse_duration) for time in t]
    a_list = [calculate_pi_x_pulse(time,args) for time in t]
    b_list = [calculate_pi_y_pulse(time,args) for time in t]

    fig, axes = plt.subplots(2, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")

    axes[0].plot(t,a_in_list,'o-')
    axes[0].set_title("MW pulses sent to the cavity")
    axes[1].plot(t,a_list,'o-')
    axes[1].plot(t,b_list,'o-')
    axes[1].set_title("MW pulses inside the cavity")
    
    return axes


def plot_HHDR_pulse(t, args):
    """Functions to plot the HHDR pulse and the pi/2-pulses actually seen by the electronic spin.
    Computes the real shape based on the signal generated by the MW sources.
    
    Parameters
    ----------
    t: float
        Time variable.
    
    args: dictionary of parameters used by the solver.
        - pi_pulse_duration: Duration of a pi pulse generated by the MW sources.
        - rabi_freq: Calibrated Rabi frequency.
        - HHDR_pulse_duration: Duration of the pulse generated by the MW sources.
        - HHDR_amplitude: Maximum amplitude of the pulse.
        - kappa: Total damping rate.
        - kappa_c: Damping rate due to external losses.
    """
    HHDR_list = [HHDR_pulse(time,args) for time in t]
    proj_list = [projection_HHDR_pulse(time,args) for time in t]

    fig, axes = plt.subplots(2, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")

    axes[0].plot(t,HHDR_list,'o-')
    axes[1].set_title("HHDR pulse seen inside the cavity")
    axes[1].plot(t,proj_list,'o-')
    axes[1].set_title("pi/2-pulses seen inside the cavity")


def inspect_electron_spin(t, result, S, *args):
    """Plots the expect values of the electron spin operator along x,y,z.
    
    Parameters
    ----------
    t: np.ndarray of floats
        Time list
        
    result: np.ndarray of Qobj
        List of statevectors obtained by the simulation
        
    S: int
        Electron spin quantum number
        
    *args: arbitrarily-long list of nuclear spin operators dimensions
    Note: it correspond to the dimensions of all the nuclear spin
    subspaces.
    (e.g. [nI_1, nI_2, nI_3] if there are 3 nuclear spins in the system)
    """
    (Sx,Sy,Sz) = generate_S(S)
    
    ops = generate_identity_ops(*args)
        
    e_spin_x = expect(tensor(*((Sx,) + ops)), result.states)
    e_spin_y = expect(tensor(*((Sy,) + ops)), result.states)
    e_spin_z = expect(tensor(*((Sz,) + ops)), result.states)

    fig, axes = plt.subplots(3, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.suptitle(r"Average of the spin operator of the electron $< \vec{S} >$")

    axes[0].set_ylabel(r"$<S_x>$")
    axes[0].plot(t, e_spin_x)

    axes[1].set_ylabel(r"$<S_y>$")
    axes[1].plot(t, e_spin_y)

    axes[2].set_ylabel(r"$<S_z>$")
    axes[2].plot(t, e_spin_z)
    
    return axes


def inspect_nuclear_spin(spin_number, t, result, I, *args):
    """Plots the expect values of the nuclear spin operator along x,y,z
    for the chosen nuclear spin.
    
    Parameters
    ----------
    spin_number: int
        Number of the nuclear spin to inspect (1 if there is only one
    nuclear spin in the system).
    
    t: np.ndarray of floats
        Time list
        
    result: np.ndarray of Qobj
        List of statevectors obtained by the simulation
        
    I: int
        Nuclear spin quantum number
        
    *args: arbitrarily-long list of electron and nuclear spin operators 
    dimensions. 
    Note: it correspond to the dimensions of all the spin
    subspaces that do not correspond to the one inspected.
    (e.g. [nS, nI_1, nI_3] if there are 3 nuclear spins and the spin #2
    is the one of interest)
    """
    (Ix,Iy,Iz) = generate_S(I)
    
    n_spins = len(args)
    if n_spins == 1:
        n_spin_x = expect(tensor(qeye(args[0]), Ix), result.states)
        n_spin_y = expect(tensor(qeye(args[0]), Iy), result.states)
        n_spin_z = expect(tensor(qeye(args[0]), Iz), result.states)
    else:
        ops_1 = generate_identity_ops(*args[0:spin_number])
        ops_2 = generate_identity_ops(*args[spin_number:])
        n_spin_x = expect(tensor(*(ops_1 + (Ix,) + ops_2)), result.states)
        n_spin_y = expect(tensor(*(ops_1 + (Iy,) + ops_2)), result.states)
        n_spin_z = expect(tensor(*(ops_1 + (Iz,) + ops_2)), result.states)

    fig, axes = plt.subplots(3, 1, sharex=True, tight_layout=True)
    fig.supxlabel("t (us)")
    fig.suptitle(r"Average of the spin operator of the nucleus $< \vec{I} >$")

    axes[0].set_ylabel(r"$<I_x>$")
    axes[0].plot(t, n_spin_x)

    axes[1].set_ylabel(r"$<I_y>$")
    axes[1].plot(t, n_spin_y)

    axes[2].set_ylabel(r"$<I_z>$")
    axes[2].plot(t, n_spin_z)
    
    return axes
